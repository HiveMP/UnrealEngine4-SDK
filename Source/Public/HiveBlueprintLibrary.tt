<#@ output extension=".h" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Net" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="Newtonsoft.Json" #>
<#
var dictionary = new Dictionary<string, WebEntry>
{
	{ "Administrative Sessions", new WebEntry("admin-session") },
	{ "Attributes", new WebEntry("attribute") },
	{ "Events", new WebEntry("event") },
	{ "Game Servers", new WebEntry("game-server") },
	{ "Integrations", new WebEntry("integration") },
	{ "Game Lobbies", new WebEntry("lobby") },
	{ "NAT Punchthrough", new WebEntry("nat-punchthrough") },
	{ "Reporting", new WebEntry("reporting") },
	{ "Revenue Share", new WebEntry("revenue-share") },
	{ "Temporary Sessions", new WebEntry("temp-session") },
	{ "UGC Cache", new WebEntry("ugc-cache") },
	{ "User Sessions", new WebEntry("user-session") },
};

var client = new WebClient();
foreach (var kv in dictionary)
{
	if (!File.Exists(kv.Value.ApiName + ".json"))
	{
		var url = "https://" + kv.Value.ApiName + "-api.hivemp.com/swagger.json";
		Console.WriteLine("Fetching " + url + "...");
		client.DownloadFile(url, kv.Value.ApiName + ".json");
	}

	var json = string.Join("", File.ReadAllLines(kv.Value.ApiName + ".json"));
	kv.Value.Api = JsonConvert.DeserializeObject<dynamic>(json);
}

Func<string, string> StripDefinition = s =>
{
	if (s.StartsWith("#/definitions/"))
	{
		return s.Substring("#/definitions/".Length);
	}
	return s;
};

Func<string, dynamic, bool, bool, string> GetCPlusPlusTypeFromParameter = null;
GetCPlusPlusTypeFromParameter = (safeName, parameter, useConst, useConstIn) =>
{
	string constName = useConst ? "const " : "";
	string arrayConstName = useConstIn ? "const " : "";
	string arrayConstSuffix = useConstIn ? "&" : "";
	string parameterType = null;
	try 
	{
		if (parameter["type"] != null)
		{
			switch ((string)parameter.type)
			{
				case "string":
				{
					switch ((string)parameter.format)
					{
						case "byte":
							parameterType = "TArray<uint8>";
							break;
						default:
							parameterType = "FString";
							break;
					}
					break;
				}
				case "integer":
				{
					switch ((string)parameter.format)
					{
						case "int32":
							parameterType = "int32";
							break;
						case "int64":
							// Long is not supported in blueprints.
							parameterType = "int32";
							break;
					}
					break;
				}
				case "number":
				{
					switch ((string)parameter.format)
					{
						case "float":
							parameterType = "float";
							break;
						case "double":
							// Double not supported by blueprints.
							parameterType = "float";
							break;
					}
					break;
				}
				case "boolean":
				{
					parameterType = "bool";
					break;
				}
				case "object":
				{
					parameterType = "FString /* JSON STRING */";
					break;
				}
				case "array":
				{
					parameterType = arrayConstName + "TArray<" + GetCPlusPlusTypeFromParameter(safeName, parameter["items"], false, useConstIn) + ">" + arrayConstSuffix;
					break;
				}
			}
		}
		else if (parameter["schema"] != null)
		{
			if (parameter.schema["type"] == "array")
			{
				parameterType = arrayConstName + "TArray<" + GetCPlusPlusTypeFromParameter(safeName, parameter.schema["items"], false, useConstIn) + ">" + arrayConstSuffix;
			}
			else if (parameter.schema["$ref"] != null)
			{
				parameterType = constName + "FHive" + safeName + "_" + StripDefinition((string)parameter.schema["$ref"]);
			}
			else
			{
				return GetCPlusPlusTypeFromParameter(safeName, parameter.schema, useConst, useConstIn);
			}
		}
		else if (parameter["$ref"] != null)
		{
			parameterType = constName + "FHive" + safeName + "_" + StripDefinition((string)parameter["$ref"]);
		}
	}
	catch (Exception ex)
	{
		Console.Error.WriteLine(ex);
		parameterType = "int32 /* unknown */ ";
	}
	return parameterType;
};

Func<string, dynamic, string> GetReferencedDefinitionName = null;
GetReferencedDefinitionName = (safeName, parameter) =>
{
	try 
	{
		if (parameter["type"] != null)
		{
			if (parameter["type"] == "array")
			{
				return GetReferencedDefinitionName(safeName, parameter["items"]);
			}
			return null;
		}
		else if (parameter["schema"] != null)
		{
			if (parameter.schema["type"] == "array")
			{
				return GetReferencedDefinitionName(safeName, parameter.schema["items"]);
			}
			else if (parameter.schema["$ref"] != null)
			{
				return StripDefinition((string)parameter.schema["$ref"]);
			}
			else
			{
				return GetReferencedDefinitionName(safeName, parameter.schema);
			}
		}
		else if (parameter["$ref"] != null)
		{
			return StripDefinition((string)parameter["$ref"]);
		}
	}
	catch (Exception ex)
	{
		Console.Error.WriteLine(ex);
		return null;
	}
	return null;
};

#>

#pragma once

#include "CoreMinimal.h"
#include "UObject/ObjectMacros.h"
#include "Net/OnlineBlueprintCallProxyBase.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "DelegateCombinations.h"
#include "OnlineSubsystem.h"
#include "JsonReader.h"
#include "JsonSerializer.h"
#include "IHttpResponse.h"
#include "GenericPlatformHttp.h"
#include "Base64.h"
#include "HiveBlueprintLibrary.generated.h"

#define UE_LOG_HIVE(Verbosity, Format, ...) \
{ \
	UE_LOG(LogOnline, Verbosity, TEXT("%s%s"), TEXT("HiveMP: "), *FString::Printf(Format, ##__VA_ARGS__)); \
}

USTRUCT(BlueprintType)
struct FHiveApiError
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadOnly)
	int32 HttpStatusCode;

	UPROPERTY(BlueprintReadOnly)
	int32 ErrorCode;

	UPROPERTY(BlueprintReadOnly)
	FString Message;

	UPROPERTY(BlueprintReadOnly)
	FString Parameter;
};

<#
foreach (var kv in dictionary)
{
	var api = kv.Value.Api;
	var safeName = kv.Value.ApiName.Replace("-", "_");

	var emittedDefinitions = new List<string>();
	Action<dynamic> EmitDefinition = null;
	EmitDefinition = def =>
	{
		if (emittedDefinitions.Contains(def.Name))
		{
			return;
		}

		if (def.Name == "HiveSystemError")
		{
			return;
		}

		foreach (var prop in def.Value.properties)
		{
			var defName = GetReferencedDefinitionName(safeName, prop.Value);
			if (defName != null)
			{
				foreach (var def2 in api.definitions)
				{
					if (def2.Name == defName)
					{
						EmitDefinition(def2);
					}
				}
			}
		}

		emittedDefinitions.Add(def.Name);

#>
USTRUCT(BlueprintType, meta=(DisplayName="HiveMP <#=kv.Key#> <#=def.Name#>"))
struct FHive<#=safeName#>_<#=def.Name#>
{
	GENERATED_BODY()

<#
		foreach (var prop in def.Value.properties)
		{
			var propType = GetCPlusPlusTypeFromParameter(safeName, prop.Value, false, false);
			if (propType != null)
			{
#>
	UPROPERTY(BlueprintReadOnly)
	<#=propType#> <#=prop.Name#>;
<#
			}
		}
#>
};
<#
	};

	foreach (var def in api.definitions)
	{
		if (def.Name == "HiveSystemError")
		{
			continue;
		}

		EmitDefinition(def);

#>

struct FHive<#=safeName#>_<#=def.Name#> DeserializeFHive<#=safeName#>_<#=def.Name#>(TSharedPtr<FJsonObject> obj);

<#
	}

	foreach (var path in api.paths)
	{
		foreach (var method in path.Value)
		{
			try
			{
				var operationId = method.Value.operationId ?? "";
				var tag = method.Value.tags[0];
				var summary = (string)(method.Value.summary ?? "");
				var description = (string)(method.Value.description ?? "");
				var displayName = summary.Replace("\"", "\\\"");
				if (displayName.IndexOf(".") != -1)
				{
					displayName = displayName.Substring(0, displayName.IndexOf("."));
				}
				if (displayName.IndexOf("  ") != -1)
				{
					displayName = displayName.Substring(0, displayName.IndexOf("  "));
				}
				var descriptionLimited = description.Length > 1000 ? (description.Substring(0, 1000) + "...") : description;
				var toolTip = descriptionLimited.Replace("\"", "\\\"").Replace("\r", "").Replace("\n", "\\n");
				
				var implName = safeName + "_" + tag + "_" + operationId;

				try 
				{
					if (method != null &&
						method.Value != null &&
						method.Value["responses"] != null &&
						method.Value.responses["200"] != null)
					{
						var parameterType = GetCPlusPlusTypeFromParameter(safeName, method.Value.responses["200"], true, true);
						if (parameterType == null)
						{
#>
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(F<#=implName#>_Delegate, const FHiveApiError&, Error);
<#
						}
						else
						{
#>
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(F<#=implName#>_Delegate, <#=parameterType#>, Result, const FHiveApiError&, Error);
<#
						}
					}
					else
					{
#>
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(F<#=implName#>_Delegate, const FHiveApiError&, Error);
<#
					}
				}
				catch (Exception ex)
				{
					Console.Error.WriteLine("DURING CALLBACK GENERATION:");
					Console.Error.WriteLine(ex);
#>
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(F<#=implName#>_Delegate, const FHiveApiError&, Error);
<#
				}
#>

UCLASS(MinimalAPI)
class U<#=implName#> : public UOnlineBlueprintCallProxyBase
{
	GENERATED_UCLASS_BODY()

	UPROPERTY(BlueprintAssignable)
	F<#=implName#>_Delegate OnSuccess;

	UPROPERTY(BlueprintAssignable)
	F<#=implName#>_Delegate OnFailure;

	UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = "true", WorldContext="WorldContextObject", DisplayName="<#=displayName#>", ToolTip="<#=toolTip#>"), Category="HiveMP|<#=kv.Key#>")
	static U<#=implName#>* PerformHiveCall(
		UObject* WorldContextObject,
		FString ApiKey
<#
				if (method.Value.parameters != null)
				{
					foreach (var parameter in method.Value.parameters)
					{
						var cppType = GetCPlusPlusTypeFromParameter(safeName, parameter, true, false);
#>
		, <#=cppType#> <#=parameter.name#>
<#
					}
				}
#>);

	// UOnlineBlueprintCallProxyBase interface
	virtual void Activate() override;
	// End of UOnlineBlueprintCallProxyBase interface

private:
	// The world context object in which this call is taking place
	UObject* WorldContextObject;

	FString ApiKey;

<#
				if (method.Value.parameters != null)
				{
					foreach (var parameter in method.Value.parameters)
					{
						var cppType = GetCPlusPlusTypeFromParameter(safeName, parameter, true, false);
#>
	<#=cppType#> Field_<#=parameter.name#>;
<#
					}
				}
#>
};

<#
			}
			catch (Exception ex)
			{
				Console.Error.WriteLine("DURING HEADER GENERATION:");
				Console.Error.WriteLine(ex);
			}
		}
	}
}
#>
<#+
    public class WebEntry
    {
		public WebEntry(string apiName)
		{
			ApiName = apiName;
		}

		public string ApiName { get; set; }
		public dynamic Api { get; set; }
    }
#>